# SQL

# SQL이란?

**SQL** (“에스큐엘” 또는 “시퀄”)은 “Structured Query Language”의 약자로, 데이터베이스에서(단, NoSQL 계열 제외) 데이터를 관리하기 위해 만들어진 프로그래밍 언어이다. 이때 “Structured”는 데이터가 표로 정리되어 구조화되어있다는 뜻이고, “Query”는 사용자가 데이터베이스에게 ‘**CRUD**(생성(Create), 조회(Read), 갱신(Update), 삭제(Delete))’ 요청을 할 수 있다는 뜻이다.

SQL은 관계형 데이터베이스를 다루는데 쓰이는 '표준화된' 언어이다. 대부분의 회사들이 SQL 형태의 인터페이스를 제공하는 서비스를 사용해 데이터를 관리한다. 따라서, 개발자라면 분야를 막론하고 기본적인 SQL문을 익혀놓는 것이 좋다.

(참고 : “ANSI SQL”이라고 하는 표준 SQL 구문이 있으나, 벤더마다 제공하는 SQL 문법은 조금씩 상이하다)

<aside>
📌 *Q. SQL이란 무엇인가?
Q. 왜 SQL을 사용하는가?*

</aside>

---

## 관련 용어 정리

- **Table / Relation :** multiset of tuples having the attributes specified by the schema.
(multiset : unordered list with duplicates)
- **Attribute / Column :** typed datat entry present in each tuple in the relation. 
(must have *atomic* types (ex. `char` `int` ...))
- **Tuple / Record / Row :** a single entry in the table having the attributes specified by the schema.
- **Cradinality** and **Arity :** 튜플의 개수와 속성의 개수

![Untitled](SQL%207dbbb/Untitled.png)

- **Key**
    
    데이터 검색, 정렬시 Tuple을 구분할 수 있는 기준이 되는 Attribute.
    
    - **Candidate Key**
        
        한 테이블 내에서 Tuple을 유일하게 식별하기 위해 사용하는 attributes의 부분 집합. 
        다시 말해, key의 값이 일치하면 동일한 tuple이다. 
        
        2가지 조건 만족 ⇒ “Key Constraints”
        
        - 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음
        - 최소성 : 꼭 필요한 최소 개수로 구성

![Untitled](SQL%207dbbb/Untitled%201.png)

- **Primary Key**
    
    후보키 중 선택한 Main Key.
    값이 NULL일 수 없고, 동일한 값이 중복돼 나타날 수 없다. 
    테이블당 최대 한 개만 존재하며, 하나도 없을 수도 있다.
    Schema에서 밑줄을 쳐 표시한다. 
    
    - ex) `Students(sid: string, name: string, gpa: float)`
- **Foreign Key**
    
    다른 테이블의 Primary Key를 그대로 참조하는 속성. (단, 속성명은 달라도 된다)
    
    (sid와 cid 모두 valid해야한다는 제약조건 ‘Integrity constraint’ 을 거는 것)
    

<aside>
📌 *Q. PK, FK, ER 모델이란?*

</aside>

---

## SQL의 종류

SQL의 종류로는 다음이 있다: 

- 
    
    ![Untitled](SQL%207dbbb/Untitled%202.png)
    

### 1. DDL

Data Definition Language, 데이터 정의어
데이터베이스 관리자가 Schema, Table 등을 정의, 변경 또는 삭제할 때 사용하는 언어이다.

![Untitled](SQL%207dbbb/Untitled%203.png)

### 2. DML

Data Manipulation Language, 데이터 조작어
사용자가 저장된 데이터에 접근, 삽입/수정/삭제하는 데 사용하는 인터페이스를 제공한다.

![Untitled](SQL%207dbbb/Untitled%204.png)

### 3. DCL

Data Control Language, 데이터 제어어
데이터 베이스 관리자가 데이터 보안, 관리를 목적으로 사용한다.

![Untitled](SQL%207dbbb/Untitled%205.png)

---

# 기본 SQL 문법 (1) Schema

### 데이터베이스 생성과 삭제

- **생성 후 사용**
    
    ```sql
    **CREATE DATABASE** userId;
    --- 데이터베이스 userId를 생성합니다.
    
    CREATE DATABASE **IF NOT EXISTS** userId;
    --- userId라는 데이터베이스가 존재하지 않는다면 생성합니다.
    
    **USE** userId;
    --- userId라는 데이터베이스에서 작업 시작합니다.
    ```
    

- **생성된 데이터베이스 모두 나열**
    
    ```sql
    **SHOW DATABASES**;
    ```
    

![Untitled](SQL%207dbbb/Untitled%206.png)

- **삭제**
    
    ```sql
    **DROP DATABASE** userId;
    --- DROP은 DB 자체를 삭제, DELETE은 DB 내용을 삭제(초기화)한다고 생각하면 됩니다.
    ```
    

### 테이블 생성, 수정, 삭제

- **테이블 스키마 생성**
    
    ```sql
    **CREATE TABLE** Students ( 
    		sid int NOT NULL AUTO_INCREMENT,    # 속성이름-타입-제약조건 순서입니다.
    		name char(10) NOT NULL DEFAULT '',
    		age int unsigned,
    		PRIMARY KEY (sid),                  # 이렇게 하지 않고 sid 의 제약조건으로 PRIMARY KEY를 걸 수도 있습니다.
      # FOREIGN KEY (gpa) REFERENCES GpaTable
    );
    --- Students 라는 테이블(의 스키마)을 만듭니다. 
    --- 필드는 sid, name, age 이고 PRIMARY KEY는 sid 이고,
    --- GpaTable이라는 테이블의 gpa 필드를 FOREIGN KEY로 참조합니다.
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%207.png)
    
    속성엔 다음 제약 조건을 걸 수 있다. 제약 조건을 거스르는 조작은 거부된다.
    
    | NOT NULL / NULL | 해당 필드는 NULL 값을 저장할 수 없다 / 해당 필드는 NULL 값을 허용한다. |
    | --- | --- |
    | UNIQUE | 각 튜플의 해당 필드 값은 테이블에서 고유해야한다. |
    | PRIMARY KEY | NOT NULL과 UNIQUE 제약 조건의 특징을 모두 가진다. |
    | FOREIGN KEY | 해당 필드는 다른 테이블의 필드에 의존한다. |
    | DEFAULT | 해당 필드의 기본값을 설정한다. |
    | AUTO_INCREMENT | 시작값 1에서, 새로운 레코드가 추가될 때마다 1씩 증가한 값으로 저장한다. |
- **테이블 스키마 보기**
    
    ```sql
    **DESCRIBE** Students;
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%208.png)
    
- **테이블 스키마 수정**
    
    ```sql
    **ALTER TABLE** Students **ADD COLUMN** department VARCHAR(20);
    --- Students 테이블에 department 라는 필드를 추가합니다.
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%209.png)
    

- **테이블 삭제**
    
    ```sql
    **DROP TABLE** Students;
    ```
    

### 데이터(튜플) 삽입, 수정, 삭제

- **삽입**
    
    ```sql
    **INSERT INTO** Students **VALUES**
    (NULL, 'David', 23, 'Electronics');
    --- 새로운 튜플을 Students 테이블에 삽입합니다.
    
    INSERT INTO Students (sid, name) VALUES (150, 'Kim');
    --- 이 다음으로 삽입되는 튜플의 sid는 (따로 설정하지 않으면) 151 이 됩니다.
    --- 값을 넣지 않은 필드(age, dept)에는 디폴트값이 들어갑니다.
    ```
    
- **테이블 내 데이터 보기**
    
    ```sql
    SELECT * FROM Students;
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%2010.png)
    
- **수정**
    
    ```sql
    **UPDATE** Students
    **SET** age = 20, department = 'Arts'
    WHERE name = 'Kim';
    --- 이름이 Kim인 학생의 age, dept 필드 값을 변경합니다.
    ```
    
- **삭제**
    
    ```sql
    **DELETE FROM** Students
    WHERE sid = 150;
    --- sid가 150인 튜플을 삭제합니다.
    
    DELETE FROM Students;
    --- 조건을 생략하면 모든 튜플이 삭제됩니다.
    ```
    

# 기본 SQL 문법 (2) Single-table Query

- 다음 데이터를 가정한다:
    
    ```sql
    CREATE TABLE Students ( 
    		sid int NOT NULL AUTO_INCREMENT,
    		name char(10) NOT NULL DEFAULT '',
    		age int unsigned,
      		gpa double NOT NULL DEFAULT '0.0',
    		PRIMARY KEY (sid)
    		# FOREIGN KEY (gpa) REFERENCES GpaTable 
    );
    ALTER TABLE Students ADD COLUMN department VARCHAR(20);
    
    INSERT INTO Students VALUES
    (100, 'Fred', 23, 3.5, 'Computer Science'),
    (NULL, 'David', 23, 3.7, 'Electronics'),
    (NULL, 'John', 21, 3.3, 'Electronics'),
    (NULL, 'Jake', 24, 4.0, 'Computer Science'),
    (NULL, 'George', 22, 2.8, 'Computer Science');
    ```
    

![Untitled](SQL%207dbbb/Untitled%2011.png)

- **SELECT** (SFW)
    
    SQL 쿼리의 기본 형태는 “**SFW query**”이다.
    간단하게 `SELECT`는 조건에 맞는 속성을, `WHERE`는 조건에 맞는 튜플을 골라낸다고 생각하면 된다.
    
    ```sql
    **SELECT** name, department 
    **FROM** Students;
    --- Students 테이블의 name, department 필드를 보여줍니다.
    --- WHERE 조건이 없으므로 모든 튜플이 대상입니다.
    
    SELECT *
    FROM Students
    **WHERE** age < 23; 
    --- * 는 모든 필드를 보여줍니다.
    --- age 값이 23 이상인 튜플만 대상입니다.
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%2012.png)
    
    - **DISTINCT**
        
        ```sql
        SELECT **DISTINCT** department FROM Students;
        --- 중복을 제거한 department 값을 보여준다.
        SELECT **DISTINCT** department, name FROM Students;
        --- 중복을 제거한 department, name "쌍"의 값을 보여준다.
        ```
        
        ![Untitled](SQL%207dbbb/Untitled%2013.png)
        
    - **LIKE**
        
        ```sql
        SELECT name FROM Students WHERE name **LIKE '_a%';
        ---** _ 는 한 개의 char, % 는 0~n개의 char를 가진다는 뜻입니다.
        --- 따라서, David Jake 가 해당됩니다.
        ```
        
    - **연산자 사용**
        
        
        | 산술 연산자  | + - / * | 논리 연산자 | and, or, not |
        | --- | --- | --- | --- |
        | 비교 연산자 | > < >= <= = != ^= <> | 비교 연산자2  | between and, in, is null, like |
        
        ```sql
        SELECT 11 / 4;
        --- 이런 수학적 연산도 가능합니다. 참고로, SELECT 11 DIV 4와 동일합니다.
        
        SELECT name FROM Students WHERE **NOT** (name LIKE '%e_' **OR** gpa >= 4.0);
        --- 이런 논리 연산도 가능합니다.
        
        SELECT * FROM Students WHERE sid **IN** (100, 103, 105);
        SELECT * FROM Students WHERE gpa **BETWEEN** 4.0 **AND** 4.5;
        --- 이런 비교 연산도 가능합니다.
        ```
        
    - **AS**
        
        ```sql
        SELECT sid **AS** '학번', name **AS** '이름' FROM Students;
        --- 필드를 별칭(alias)으로 보여줍니다.
        ```
        
        ![Untitled](SQL%207dbbb/Untitled%2014.png)
        

- **ORDER BY**
    
    ```sql
    SELECT name, age, gpa FROM Students
    **ORDER BY** age **ASC**, gpa **DESC**;
    --- 기준에 따라 정렬합니다. 콤마(,)로 여러 기준을 나열할 수 있습니다.
    --- 첫번째 기준 age 에서 동률인 항목이 두번째 기준 gpa 로 정렬됩니다.
    --- 기본은 오름차순이나, DESC 키워드로 내림차순으로 정렬할 수 있습니다.
    --- 문자열은 알파벳 순으로 정렬됩니다.
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%2015.png)
    
    - **LIMIT**
        
        ```sql
        SELECT name, gpa FROM Students ORDER BY gpa DESC **LIMIT 3;
        ---** gpa 를 내림차순한 상태로 상위 3 개만 보여줍니다.
        --- LIMIT 0,3 => 0 순위부터 3개만 보여줍니다.
        ```
        
    
- **GROUP BY**
    
    특정 속성의 값이 같은 튜플들을 임시로 묶음 처리 해준다.
    
    ```sql
    SELECT department FROM Students **GROUP BY** department;
    --- 같은 department 값을 가진 튜플끼리 임시로 묶여있다.
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%2016.png)
    
    - **AGGREGATION**
        
        그룹핑은 다음 계산 함수들과 자주 함께 사용된다. 같이 묶인 튜플의 값끼리 처리된다.
        
        | max / min | avg | count | sum | std |
        | --- | --- | --- | --- | --- |
        
        ```sql
        SELECT department, 
        COUNT(*) AS '인원수',     # COUNT(gpa) 도 결과는 동일합니다.
        MAX(gpa) AS '최고학점',
        SUM(gpa) AS '총합', 
        AVG(gpa) AS '평균'
        FROM Students GROUP BY department;
        ```
        
        ![Untitled](SQL%207dbbb/Untitled%2017.png)
        
    - **HAVING**
        
        언제나 `GROUP BY` 와 함께 사용되며, 조건에 맞는 ‘그룹’을 추출한다. 
        
        📌 `WHERE` 와 `HAVING` 의 차이점? `WHERE`는 개별 튜플을 필터링하는 데 사용되지만, `HAVING`은 그룹화 또는 집계가 발생한 후 그룹을 필터링하는 데 사용된다. 따라서 그룹핑 후에 조건을 줄 땐 반드시 `HAVING`을 써야 한다. 
        
        ```sql
        SELECT department, AVG(age) FROM Students
        GROUP BY department
        HAVING COUNT(*) > 2;
        --- department 값이 같은 튜플끼리 묶은 후, 포함된 튜플의 개수가 2 초과인 그룹만 고릅니다.
        ```
        
        ![Untitled](SQL%207dbbb/Untitled%2018.png)
        

### 정리하자면...

```sql
SELECT 속성
FROM 테이블
WHERE 테이블조건
GROUP BY 속성
HAVING 그룹조건
ORDER BY 속성
```

# 기본 SQL 문법 (3) Multi-table Query

### 다른 테이블 FOREIGN KEY CONSTRAINT 걸기

1. 새로운 테이블을 생성한다.
    - 코드
        
        ```sql
        CREATE TABLE Course (
          cid int unsigned NOT NULL PRIMARY KEY,
          code char(5), name varchar(20), credit int
        );
        
        INSERT INTO Course VALUES
        		(10, 'ITE01', 'Database', 3),
            (11, 'ITE02', 'OS', 3),
            (12, 'ITE03', 'Network', 3);
        ```
        

![Untitled](SQL%207dbbb/Untitled%2019.png)

1. Students 테이블에 `FOREIGN KEY`를 추가한다.
    
    ```sql
    ALTER TABLE Students ADD COLUMN cid int unsigned NOT NULL DEFAULT 0;
    UPDATE Students SET cid = 10;
    
    ALTER TABLE Students ADD **FOREIGN KEY (cid) REFERENCES Course (cid);**
    --- Course 테이블의 cid 를 참조하는 FOREIGN KEY 필드인 cid 를 Students 에 추가합니다.
    ```
    
    ![Untitled](SQL%207dbbb/Untitled%2020.png)
    
2. Students 테이블의 cid 값을 수정한다.
    - 코드
        
        ```sql
        UPDATE Students SET cid = 10 WHERE name = 'Fred';
        UPDATE Students SET cid = 11 WHERE name = 'David';
        UPDATE Students SET cid = 12 WHERE name = 'John';
        UPDATE Students SET cid = 10 WHERE name = 'Jake';
        UPDATE Students SET cid = 11 WHERE name = 'George';
        ```
        

### 테이블 JOIN하기

- **JOIN**
    
    여러 테이블을 조합해 하나의 결과 테이블을 만든다.
    결과는 두 테이블의 튜플들의 **주어진 조건에 맞는** 가능한 모든 조합을 포함한다.
    
    즉, JOIN은 
    
    (1) 두 테이블의 cross product 를 구해 
    (2) Selection/조건을 적용해 필터링하고
    (3) Pojection을 적용해 결과 테이블을 얻는다는 의미이다. 
    
    ```sql
    SELECT * FROM Product, Company
    WHERE Manufacturer = CName
    ```
    

![Untitled](SQL%207dbbb/Untitled%2021.png)

- **INNER JOIN**
    
    일반적인 조인. 기준 테이블과 조인 테이블 모두 데이터가 존재해야 조회된다.
    
    ```sql
    SELECT * FROM Students INNER JOIN Course;
    ```
    

### JOIN

**INNER JOIN**

```sql
SELECT A.a, B.b 
FROM A
JOIN B ON B.a = A.c;    # ON 대신 WHERE를 사용할 수 있다.
```

**LEFT OUTER JOIN**

A 테이블의 모든 튜플과, 이에 상응하는 key 값이 있는 B 테이블의 튜플이 조인된다. 일치하는 값이 없는 경우 B 테이블의 칼럼은 NULL로 조인된다.

```sql
SELECT A.a, A.b, B.c 
FROM A
LEFT OUTER JOIN B ON B.a = A.c;    # OUTER 생략할 수 있다
```

**RIGHT OUTER JOIN**

LEFT JOIN과 비슷하나 B 테이블을 기준으로 조인한다. 

```sql
SELECT A.a, A.b, B.c 
FROM A
RIGHT OUTER JOIN B ON B.a = A.c;    # 역시 OUTER 생략할 수 있다
```

**CROSS JOIN (Cartesian JOIN)**

집합의 곱 (또는 중첩 for문) 개념으로 A= {a, b} , B = {1, 2, 3} 일 때 결과는 (a,1), (a, 2), (a,3), (b,1), (b,2), (b,3)가 된다. 결과의 개수는 n(A) * n(B) 이다.

```sql
SELECT A.a A.b B.c
FROM A
CROSS JOIN B;
// 위 아래 쿼리의 결과는 같다.
SELECT A.a, A.b, B.c
FROM A, B;
```

**SELF JOIN**

일반 JOIN과 동일하나 조인하는 테이블이 자기 자신이다. 또한 두 테이블을 구별하기 위해 별칭(Alias)를 만들어줘야 한다. 

```sql
SELECT A.a, B.b
FROM Students S1
INNER JOIN Students S2
```

<aside>
📌 *Q. inner join과 outer join 차이*

*Q. having과 where 차이*

*Q. group by의 역할*

</aside>

언어 specific한 질문 (1) python list 어떻게 이뤄졌나 (2) python sort하면 어떻게 되냐

디자인패턴